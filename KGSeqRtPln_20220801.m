% function [OptChc,Result,TotFlow,T,ErrRate,PilotPre]=KGSeqRtPln_20220715(M,Run,CorFlow2,PUMAODinfo2,TrueCov) % with pilot generation
% function [OptChc,Result,TotFlow,T,ErrRate]=KGSeqRtPln(M,Run,PilotPre,CorFlow2,PUMAODinfo2,TrueCov) % with generated pilot
function [OptChc,Result,TotFlow,T,ErrRate]=KGSeqRtPln_20220801(M,Run,level,policy) % with saved pilot
%{
ULTIMATE GOAL
1. Compatible with all networks
   : revise network-specific modules (e.g. grid or NYC PUMA)
2. Adjustable transferability
   : introduce 'switch' to indicate the consideration of transfers
3. Concise code
   : append functions at the end of the code

STEPS
1. Bring codes and aggregate into one
2. Make functions from repetitive lines
3. Generalize network-specific lines
%}

%% DATA PREPARATION
%{
[EXPERIMENTS]
#1: Artificial grid network
[Data list]
1.
2.
3.
4.

[Source of data]
All data were generated.


#2: NYC PUMA network (55 nodes, 246 links)
[Data list]
1. Node information (INDEX/ID/LON/LAT/COUNTY): PUMANode
2. Link information (ID/O/D/OINDEX/DINDEX/TT): PUMALink
3. Mean of OD flows (ID/OINDEX/DINDEX/MEAN/VARIANCE): PUMAODinfo
4. Covariance matrix of OD flows: 

[Source of data]
1. Network: generated based on road network on Google Maps
2. Mean OD flow: NYMTC 2010 HHTS DATASET, UNLINKED_PUBLIC
3. Covariance matrix of OD flow: generated by "FUNCTION"
%}
% load("PUMA_final.mat","PUMAODinfo","ReachableNodes","LinkInfo","MinPath"); % data for Exp2
% Link list, Coordinates of nodes, OD pair information, OD flow covariance, Minimum paths from nodes

% CREATE INPUT FROM LINK LIST (LinkInfo & MinPath)
% INPUT NETWORK (LINK-NODE INFORMATION)
% A=[PUMALink(:,1),PUMALink(:,4:6)];
% LinkInfo=transpose(A);   % transpose to fit "digraph" input
% Nodei=LinkInfo(2,:);                        % start nodes (1-by-nLink)
% Nodej=LinkInfo(3,:);                        % end nodes (1-by-nLink)
% Tij=LinkInfo(4,:);                          % travel time

% EdgeInfo=zeros(4,123);
% for i=1:123
%     EdgeInfo(:,i)=LinkInfo(:,2*i-1);
%     EdgeInfo(4,i)=(sum(LinkInfo(4,2*i-1:2*i))/2);
% end
% EdgeInfo(1,:)=(1:123);
% Nodei=EdgeInfo(2,:);
% Nodej=EdgeInfo(3,:);
% Tij=EdgeInfo(4,:);

%% FIND MINIMUM PATH FROM ALL NODES
% G=digraph(Nodei,Nodej,Tij);	% graph with directed edges
% % plot(G, 'EdgeLabel', G.Edges.Weight);    % plot network with LinkID and c_ij
% Node=unique([Nodei,Nodej]); % list of unique nodes on network
% nNode=size(Node,2);         % # of nodes

% G=graph(Nodei,Nodej,Tij);
% % plot(G, 'EdgeLabel', G.Edges.Weight);
% Node=unique([Nodei,Nodej]);
% nNode=size(Node,2);

% PUMAinfo=[(1:nNode*(nNode-1)/2)',zeros(nNode*(nNode-1)/2,4)];
% k=0;
% for i=1:nNode-1
%     for j=i+1:nNode
%         k=k+1;
%         PUMAinfo(k,2:end)=PUMAODinfo(PUMAODinfo(:,2)==i&PUMAODinfo(:,3)==j,2:end);
%         PUMAinfo(k,4)=PUMAinfo(k,4)+PUMAODinfo(PUMAODinfo(:,2)==j&PUMAODinfo(:,3)==i,4);
%     end
% end

% MinPath=struct; % Prepare struct for minimum paths
% for i=1:nNode
%     [MinPath(i).Paths,MinPath(i).T_ij] = shortestpathtree(G,i,'all','OutputForm','cell');
%     %.Paths: minimum paths from i to other nodes
%     %.T_ij: path cost from i to other nodes
%     % LINK-OD INCIDENCE MATRIX & LINK ON MINIMUM PATHS
%     for j=1:nNode
% %         [~,ODID]=ismember([i,j],PUMAODinfo2(:,2:3),'rows');    % ODflowID
%         ODID=PUMAinfo(PUMAinfo(:,2)==i&PUMAinfo(:,3)==j,1);
% %         ODID=sum(ODFLOWID);
%         len=size(MinPath(i).Paths{j,1},2);    % # of nodes to connect i and j
%         if len>1 % origin and destination are different
%             % IDENTIFY LINKS USED BY EACH MINIMUM PATH BRANCH
%             MinPath(i).Links{j,1}=0;   % prepare array for included link IDs
%             for k=1:len-1
%                 m=EdgeInfo(1,EdgeInfo(2,:)==MinPath(i).Paths{j,1}(k)&EdgeInfo(3,:)==MinPath(i).Paths{j,1}(k+1));
%                 if size(m,2)==0
%                     m=EdgeInfo(1,EdgeInfo(2,:)==MinPath(i).Paths{j,1}(k+1)&EdgeInfo(3,:)==MinPath(i).Paths{j,1}(k));
%                 end    
%                 MinPath(i).Links{j,1}(k)=m;
%             end
% 
%             % IDENTIFY OD PAIRS COVERED BY EACH MINIMUM PATH BRANCH
%             MinPath(i).ODs{j,1}=0;   % prepare array for covered OD IDs
%             col_ind=1;
%             for k=1:len-1
%                 for m=k+1:len
%                     if MinPath(i).Paths{j,1}(k)<MinPath(i).Paths{j,1}(m)
%                         ODID2=PUMAinfo(PUMAinfo(:,2)==MinPath(i).Paths{j,1}(k)&PUMAinfo(:,3)==MinPath(i).Paths{j,1}(m),1);
%                     else
%                         ODID2=PUMAinfo(PUMAinfo(:,2)==MinPath(i).Paths{j,1}(m)&PUMAinfo(:,3)==MinPath(i).Paths{j,1}(k),1);
%                     end
%                     MinPath(i).ODs{j,1}(col_ind)=ODID2;
%                     col_ind=col_ind+1;
%                 end
%             end
%         end
%     end
% end

%% CREATE COVARIANCE MATRIX OF TRUE MEAN FLOW
% nPairSignif=300; % # of significant pairs (whose correlation is important)
% [TrueUncorrPairL,TrueCorrPairMeanL,TrueCorrPairCovL,FlowClusterL,PriorPairsL]=GenFakeTruth(PUMAinfo,nPairSignif,NodeCluster,1);
% [TrueUncorrPairM,TrueCorrPairMeanM,TrueCorrPairCovM,FlowClusterM,PriorPairsM]=GenFakeTruth(PUMAinfo,nPairSignif,NodeCluster,2);
% [TrueUncorrPairH,TrueCorrPairMeanH,TrueCorrPairCovH,FlowClusterH,PriorPairsH]=GenFakeTruth(PUMAinfo,nPairSignif,NodeCluster,3);

% nPairSignif=300; % # of significant pairs (whose correlation is important)
% [TrueUncorrPairL,TrueCorrPairMeanL,TrueCorrPairCovL,FlowClusterL,PriorPairsL]=GenFakeTruth(PUMAinfo,nPairSignif,NodeGroup,1);
% [TrueUncorrPairM,TrueCorrPairMeanM,TrueCorrPairCovM,FlowClusterM,PriorPairsM]=GenFakeTruth(PUMAinfo,nPairSignif,NodeGroup,2);
% [TrueUncorrPairH,TrueCorrPairMeanH,TrueCorrPairCovH,FlowClusterH,PriorPairsH]=GenFakeTruth(PUMAinfo,nPairSignif,NodeGroup,3);


% Generate the same fake true mean but different std.devs and covariances
% nPairSignif=300;
% [TrueUncorrPair,TrueCorrPairMean,TrueCorrPairCovL,TrueCorrPairCovM,TrueCorrPairCovH,FlowCluster,PrUncorrPair,PrCorrPairMean]=GenFakeTruthVar(PUMAinfo,nPairSignif,NodeCluster);
% PrCorrPairMeanL=PrCorrPairMean(:,1:3);
% PrCorrPairMeanM=PrCorrPairMean(:,[1,2,4]); 
% PrCorrPairMeanH=PrCorrPairMean(:,[1,2,5]);
% PrUncorrPairL=PrUncorrPair(:,1:3);
% PrUncorrPairM=PrUncorrPair(:,[1,2,4]); 
% PrUncorrPairH=PrUncorrPair(:,[1,2,5]);
% TrueCorrPairMeanL=TrueCorrPairMean(:,1:3);
% TrueCorrPairMeanM=TrueCorrPairMean(:,[1,2,4]);
% TrueCorrPairMeanH=TrueCorrPairMean(:,[1,2,5]); 
% TrueUncorrPairL=TrueUncorrPair(:,1:3);
% TrueUncorrPairM=TrueUncorrPair(:,[1,2,4]); 
% TrueUncorrPairH=TrueUncorrPair(:,[1,2,5]);

%{
How to deal with covariance matrix?
In the previous version, OD pairs are grouped and covariance matrices for
them were generated separately. 
Now, the code generates covariance matrix with all significant OD flows
larger than criterion. Therefore, we need to revise the code.
1) Relate OD flow ID and covariance matrix location.
2) When generating, recall them and simulate.
%}

%% INITIAL SETTING AND LOADING DATA
% load("Input_20220411.mat",'CorFlow2','LinkInfo','MinPath','nNode','nOD','PUMAODinfo2','ReachableNodes','TrueCov'); % generated dataset
% load("Input_20220411.mat",'CorFlow2','LinkInfo','MinPath','nNode','nOD','PUMAODinfo2','ReachableNodes','TrueCov','PilotPre'); % pilot data and generated covariance matrix (PUMA)
% load("Input_20220411.mat",'LinkInfo','MinPath','nNode','nOD','ReachableNodes'); % generated dataset
% load("Input_20220405_grid#1.mat");

% load("Input_20220726.mat",'LinkInfo','MinPath','nNode','nOD','PUMAinfo','ReachableNodes','EdgeInfo');
% load("Input_20220726.mat",'PilotPreL','FlowCluster','TrueCorrPairCovL','TrueCorrPairMeanL','TrueUncorrPairL'); % truths

load("Input_20220803_grid_1.mat")

% if level==1
%     TrCorrCov=TrueCorrPairCovL;
%     TrCorrMean=TrueCorrPairMeanL;
%     TrUncorr=TrueUncorrPairL;
%     FlowCluster=FlowClusterL;
%     PilotPre=PilotPreL;
% elseif level==2
%     TrCorrCov=TrueCorrPairCovM;
%     TrCorrMean=TrueCorrPairMeanM;
%     TrUncorr=TrueUncorrPairM;
%     FlowCluster=FlowClusterM;
%     PilotPre=PilotPreM;
% else
%     TrCorrCov=TrueCorrPairCovH;
%     TrCorrMean=TrueCorrPairMeanH;
%     TrUncorr=TrueUncorrPairH;
%     FlowCluster=FlowClusterH;
%     PilotPre=PilotPreH;
% end

PUMAinfo=FlowInfo;
TrCorrCov=Truth(level).CovMat;
TrCorrMean=Truth(level).CorrMeanStd;
TrUncorr=Truth(level).UncorrMeanStd;
if level==1 % Scenario #1 Random
    PilotPre=PilotPre1;
elseif level==2 % Scenario #2 Monocentric
    PilotPre=PilotPre2;
else % Scenario #3 Polycentric
    PilotPre=PilotPre3;
end

% M=1; Run=10;

T=zeros(Run,1); % time calculation
Result=struct;  % prepare the space for archiving results
nReqRoute=6;   % # of routes to build
minpilotL=6;    % minimum length (# of nodes) of pilot route
maxL=3;         % maximum length (# of nodes) of chosen route

% Nodei=LinkInfo(2,:);        % start nodes (1-by-nLink)
% Nodej=LinkInfo(3,:);        % end nodes (1-by-nLink)
% Tij=LinkInfo(4,:);          % cost on links (or travel time)

% Truth for 2 flow groups (uncorrelated vs correlated)
% TrueUncorrFlow: mean and std.dev
% TrueCorrFlowMean: mean
% TrueCorrFlowCov: covariance

%% Separate PUMAinfo by whether OD is correlated or not
m=0; n=0;
for i=1:nOD
    if ismember(PUMAinfo(i,1),TrUncorr(:,1))
        m=m+1;
        PUMAinfoUncorr(m,:)=PUMAinfo(i,:);
    else
        n=n+1;
        PUMAinfoCorr(n,:)=PUMAinfo(i,:);
    end
end


PairperNode=cell(nNode,2);
for i=1:size(PUMAinfoUncorr,1)
    PairperNode{PUMAinfoUncorr(i,2),1}(end+1)=PUMAinfoUncorr(i,1);
    PairperNode{PUMAinfoUncorr(i,3),1}(end+1)=PUMAinfoUncorr(i,1);
end
for i=1:size(PUMAinfoCorr,1)
    PairperNode{PUMAinfoCorr(i,2),2}(end+1)=PUMAinfoCorr(i,1);
    PairperNode{PUMAinfoCorr(i,3),2}(end+1)=PUMAinfoCorr(i,1);
end

%%

% % TrueODMean=PUMAODinfo2(:,4);	% true mean of OD flows
% % TrueODStdev=PUMAODinfo2(:,5);	% true std.dev of OD flows    

% M=1;    % # of observations for single-link extension, should be greater than number of choices
mabsetting=0; kggeneral=0; kgcb=0;
if policy==100
    mabsetting=1;	% 1 for Multi-armed bandit algorithm, 0 otherwise
elseif policy==200
    kggeneral=1;    % 1 for Knowledge gradient, 0 otherwise
elseif policy==300
    kgcb=1;         % 1 for Knowledge gradient with correlated belief, 0 otherwise
end
assert((mabsetting + kggeneral + kgcb)==1);
    
%% GENERATE PILOT OPERATIONS (ONLY IF GENERATED PILOT DOES NOT EXIST)
% nPilot=30;	% # of pilots
% nTimes=10;  % # of operations per pilot
% minpilotL=5;
% % PilotPre=struct;
% nSet=1;     % # of pilot data required
% % PILOT GENERATION BEFORE FIXING SAMPLE ROUTE SET
% for simul=1:nSet
%     [PilotPre(simul).PrUncorrFlow,PilotPre(simul).PrCorrFlowMean,PilotPre(simul).PrCorrFlowCov,PilotPre(simul).ObsOD,PilotPre(simul).PilotStartEnd,PilotPre(simul).PrecisU,PilotPre(simul).PrecisC]=PilotGen(nPilot,nTimes,minpilotL,nNode,nOD,MinPath,TrUncorr,TrCorrMean,TrCorrCov,FlowCluster,PriorPairs,ExpCorrList);
% %     [PilotPreL(simul).PrUncorrFlow,PilotPreL(simul).PrCorrFlowMean,PilotPreL(simul).PrCorrFlowCov,PilotPreL(simul).ObsOD,PilotPreL(simul).PilotStartEnd,PilotPreL(simul).PrecisU,PilotPreL(simul).PrecisC]=PilotGen(nPilot,nTimes,minpilotL,nNode,nOD,MinPath,TrueUncorrPairL,TrueCorrPairMeanL,TrueCorrPairCovL,FlowClusterL,PriorPairsL,ExpCorrList);
% %     [PilotPreH(simul).PrUncorrFlow,PilotPreH(simul).PrCorrFlowMean,PilotPreH(simul).PrCorrFlowCov,PilotPreH(simul).ObsOD,PilotPreH(simul).PilotStartEnd,PilotPreH(simul).PrecisU,PilotPreH(simul).PrecisC]=PilotGen(nPilot,nTimes,minpilotL,nNode,nOD,MinPath,TrueUncorrPairH,TrueCorrPairMeanH,TrueCorrPairCovH,FlowClusterH,PriorPairsH,ExpCorrList);
% %     [PilotPreM(simul).PrUncorrFlow,PilotPreM(simul).PrCorrFlowMean,PilotPreM(simul).PrCorrFlowCov,PilotPreM(simul).ObsOD,PilotPreM(simul).PilotStartEnd,PilotPreM(simul).PrecisU,PilotPreM(simul).PrecisC]=PilotGen(nPilot,nTimes,minpilotL,nNode,nOD,MinPath,TrueUncorrPairM,TrueCorrPairMeanM,TrueCorrPairCovM,FlowClusterM,PriorPairsM,ExpCorrList);
% end

% % PILOT GENERATION AFTER FIXING SAMPLE ROUTE SET
% PilotStartEnd=PilotPreL.PilotStartEnd;
% for simul=1:nSet
% %     [PilotPre(simul).PriorODMean,PilotPre(simul).CovOD,PilotPre(simul).PriorODStdev,PilotPre(simul).ObsOD,PilotPre(simul).PilotStartEnd]=PilotGen(nPilot,nTimes,minpilotL,nNode,nOD,PUMAODinfo2,TrueCov,CorFlow2,MinPath,PilotStartEnd);
%     [PilotPreH(simul).PrUncorrFlow,PilotPreH(simul).PrCorrFlowMean,PilotPreH(simul).PrCorrFlowCov,PilotPreH(simul).ObsOD,PilotPreH(simul).PilotStartEnd,PilotPreH(simul).PrecisU,PilotPreH(simul).PrecisC]=PilotGen(nPilot,nTimes,minpilotL,nNode,nOD,MinPath,TrueUncorrPairH,TrueCorrPairMeanH,TrueCorrPairCovH,FlowClusterH,PrUncorrPairH,PrCorrPairMeanH,PilotStartEnd);
%     [PilotPreM(simul).PrUncorrFlow,PilotPreM(simul).PrCorrFlowMean,PilotPreM(simul).PrCorrFlowCov,PilotPreM(simul).ObsOD,PilotPreM(simul).PilotStartEnd,PilotPreM(simul).PrecisU,PilotPreM(simul).PrecisC]=PilotGen(nPilot,nTimes,minpilotL,nNode,nOD,MinPath,TrueUncorrPairM,TrueCorrPairMeanM,TrueCorrPairCovM,FlowClusterM,PrUncorrPairM,PrCorrPairMeanM,PilotStartEnd);
% end

%% LOAD PREGENERATED PILOT DATASET
% load("PUMA_final.mat",'PilotPre');
% load("PUMA_priortest.mat",'PilotPre_S2S3_low');
% PilotPre=PilotPre_S2S3_low;    % low variation
% PilotPre=PilotPre_S2S3_high;   % high variation

%% REPEAT EXPERIMENTS
%{ 
STEPS
1. Designate N_11, the initial node of the 1st route R1, from the
network node set       
2. Extend link by link from N_11
3. When reaching maxL, finalize R1
For 1<k<=nReqRoute
4. Designate N_k1, the initial node of the k-th route Rk, from the
system node set (to increase transferability)
5. Extend link by link from N_k1
6. When reaching maxL, finalize Rk
7. k=k+1
8. When k>nReqRoute, stop.
%}
for i=1:Run
    Result(i).Err=[0,0];
end

nSim=0; % # of experiments conducted
while nSim<Run
    try
    tic
    %% PREPARE SPACE FOR RESULT AND ARCHIVES
    EstMeanODFlow=[];   % Estimated mean OD flow of all OD pairs
    
    % LINK ARCHIVE % Use "IncludedLink" instead
        % LinkChoice = []; % explored during each extension
        % LinkRoute = []; % archive links included in route during each route installation
        % LinkSystem = []; % archive included links, grouping by route
        % LinkSystemNet = []; % archive all links included (without grouping)
    IncludedLink=[];        % space for links included in the system (empty at the beginning)
    RemainingLink=EdgeInfo; % links remaining uncovered (all links remain at the beginning)
    
    % NODE ARCHIVE
        % NodeChoice = []; % byproduct of LinkChoice (unnecessary)
        % NodeSystem = []; % archive included nodes, grouping by route ("Route" in Struct "Result")
    NodeRoute = []; % archive nodes included in route during each route installation
    NodeSystemNet = []; % archive all nodes included (without grouping)
    
    % OD PAIR ARCHIVE
        % ODChoice = []; % newly available OD pairs per choice
        % ODRoute = []; % archive OD pairs become available during each route installation (in "ODwithRTpair")
        % ODSystem = cell(nReqRoute,nReqRoute); % not required
    ODSystemNet=[]; % ODs served by routes
    
    % INCIDENCE MATRICES
        % ODRouteIncid=zeros(nOD,1); % OD vs Route

    % LIST OF ROUTES VISITING A NODE
    NodeRouteList=cell(nNode,2);    % routes that serves a node
    for i=1:nNode
        NodeRouteList{i,1}=i; % 1st column: node ID, 2nd column: routes visiting i-th node
    end
    
    % INDICATOR OF TRANSFERABILITY
    RTintsct=eye(nReqRoute);	% if RTintsct(i,j)=1: i and j are transferable
    RTGroups=cell(nReqRoute,2); % group of routes mutually transferable
    for i=1:nReqRoute
        RTGroups{i,1}=i; % 1st column: route ID, 2nd column: transferable routes from i-th route
    end
    
    % OPPORTUNITY COST
    % Opportunity cost can be observed by subtracting the value of chosen
    % link from that of the best link 
    % (Only under oracle setting. In reality, it's impossible.)
    OPPCOST={};	% archive for opportunity costs per extension
    OppCost=cell(maxL,5);	% empty cell for opportunity cost [route,chosen node,choice made,true best,opportunity cost]
    
    %% RECALL GENERATED PRIORS
%     PriorODMean=PilotPre.PriorODMean;   % prior mean of OD flows
%     PriorODStdev=PilotPre.PriorODStdev; % prior std.dev of OD flows
%     CovOD=PilotPre.CovOD;               % prior covariance matrix of OD flows
%     for i=1:nOD
%         for j=1:nOD
%             if CovOD(i,j)==0
%                 CovOD(i,j)=1;
%             end
%         end
%     end
    PrUncorr=PilotPre.PrUncorrFlow;
    PrCorrMean=PilotPre.PrCorrFlowMean;
    PrCorrCov=PilotPre.PrCorrFlowCov;
    ObsOD=PilotPre.ObsOD;               % observed OD flows during pilots
    PrecisU=PilotPre.PrecisU;
    PrecisC=PilotPre.PrecisC;
    nUncorrFlow=size(PrUncorr,1);
    nCorrFlow=size(PrCorrMean,1);
    
    %% DESIGNATE THE INITIAL NODE OF THE 1ST ROUTE AND BEGIN THE EXTENSION
    RT=1; % begin with the 1st route
    OppCost{1,1}=RT;    % opportunity cost of the 1st route will be archived
    
    % LARGEST IN- AND OUTFLOW TO ALL OTHER NODES (FROM PILOT)
    NodeNetFlow=zeros(1,nNode);	% aggregated in- and outflow of all nodes
    for i=1:nUncorrFlow
        af=PrUncorr(PrUncorr(:,1)==PUMAinfoUncorr(i,1),2);
        NodeNetFlow(PUMAinfoUncorr(i,2))=NodeNetFlow(PUMAinfoUncorr(i,2))+af;
        NodeNetFlow(PUMAinfoUncorr(i,3))=NodeNetFlow(PUMAinfoUncorr(i,3))+af;
    end
    for i=1:nCorrFlow
        af=PrCorrMean(PrCorrMean(:,1)==PUMAinfoCorr(i,1),2);
        NodeNetFlow(PUMAinfoCorr(i,2))=NodeNetFlow(PUMAinfoCorr(i,2))+af;
        NodeNetFlow(PUMAinfoCorr(i,3))=NodeNetFlow(PUMAinfoCorr(i,3))+af;
    end
%     for i=1:nNode
%         NodeNetFlow(1,i)=sum(PrUncorrFlow(PUMAODinfoUnCorr(:,2)==i,2))+sum(PrUncorrFlow(PUMAODinfoUnCorr(:,3)==i,2)); % aggregate all OD flows from/to i-th node
%     end
    [~,start]=max(NodeNetFlow(:));	% node with maximum total flow
    NodeRoute=start;                % add this node to 1st route
    OppCost{1,2}=start;             % 1st choice is "start"
    NodeSystemNet=start;            % list of nodes covered by system
    NodeRouteList{start,2}=RT;      % route "RT" covers node "start"
        
    % IDENTIFY AVAILABLE LINKS FROM THE INITIAL NODE
    LinkChoice1=[find(EdgeInfo(2,:)==start),find(EdgeInfo(3,:)==start)]; % find links connected to the node
    nCandLink=size(LinkChoice1,2);          % # of available links
    ODChoice=cell(1,nCandLink);             % cell for total OD covered if extending to a link
%     ODChoiceInd=zeros(nOD,nCandLink);       % indicate ODs that covered by choices
    ODChoiceIndUncorr=zeros(nUncorrFlow,nCandLink);
    ODChoiceIndCorr=zeros(nCorrFlow,nCandLink);
%     for i=1:nCandLink
%         ODChoiceInd(:,i)=ODRouteIncid;    % bring previous ODRouteIncid
%     end

    % PREPARE TRUTH AND PRIOR OF MEAN AND STD.DEV OF REWARD FROM CHOICES
    Mu=zeros(nCandLink,1);      % mean flow based on truth
    Mu0=zeros(nCandLink,1);     % mean flow based on prior
    Sigma=zeros(nCandLink,1);	% std.dev of flow based on truth
    Sigma0=zeros(nCandLink,1);	% std.dev of flow based on prior
    for i=1:nCandLink
        % Since there are only two nodes, one OD pair exists
        ODTemp=EdgeInfo(2:3,LinkChoice1(i))'; 
        % Convert (o,d) to OD flow ID
        ODFLOWIDTemp=zeros(1,1); 
        [~,ODFLOWIDTemp(1,1)]=ismember(ODTemp(1,:),PUMAinfo(:,2:3),'rows'); % bring flow ID of given (o,d)
        ODFLOWIDTemp(ODFLOWIDTemp(:,1)==0)=[];  % delete OD flow that does not exist
        ODChoice{1,i}=ODFLOWIDTemp';    % total OD covered by i-th choice
        for j=1:size(ODChoice{1,i},2)
%             ODChoiceInd(ODChoice{1,i}(j),i)=1; 	% update indicators
            if ismember(ODChoice{1,i}(j),PrCorrMean(:,1)) % correlated
                ODChoiceIndCorr(PrCorrMean(:,1)==ODChoice{1,i}(j),i)=1;
            else
                ODChoiceIndUncorr(PrUncorr(:,1)==ODChoice{1,i}(j),i)=1;
            end
        end
        
        % AGGREGATE TRUTHS AND PRIORS ON FLOW LEVEL TO CHOICE LEVEL
%         Mu(i,1)=TrueODMean'*ODChoiceInd(:,i); % true mean flow by choosing a link
        Mu(i,1)=TrUncorr(:,2)'*ODChoiceIndUncorr(:,i)+TrCorrMean(:,2)'*ODChoiceIndCorr(:,i);
        % There are many possible ways to assume initial prior of mean
        % flow not observed during the pilot. Here, the algorithm assumes
        % they are mean of all observed OD flows during pilots.
%         Pom=PriorODMean(:,1);       % current prior of OD flow
%         meanAll=mean(Pom(Pom>0));   % current mean of observed OD flow
        AllMeans=[PrCorrMean(:,2);PrUncorr(:,2)];
        meanAll=mean(AllMeans(AllMeans>0));
        % Prior OD flow by choosing a link
        for j=1:nUncorrFlow
            if ODChoiceIndUncorr(j,i)>0 % j-th flow is covered by i-th choice
                if PrUncorr(j,2)==0 % if not observed
                    Mu0(i,1)=Mu0(i,1)+meanAll; % add mean value of the observed instead of zero
                else % if observed
                    Mu0(i,1)=Mu0(i,1)+PrUncorr(j,2); % add obseved mean flow
                end
            end
        end
        for j=1:nCorrFlow
            if ODChoiceIndCorr(j,i)>0 % j-th flow is covered by i-th choice
                if PrCorrMean(j,2)==0 % if not observed
                    Mu0(i,1)=Mu0(i,1)+meanAll; % add mean value of the observed instead of zero
                else % if observed
                    Mu0(i,1)=Mu0(i,1)+PrCorrMean(j,2); % add obseved mean flow
                end
            end
        end
%         for j=1:nOD
%             if ODChoiceInd(j,i)>0 % j-th flow is covered by i-th choice
%                 if PriorODMean(j,1)==0 % if not observed
%                     Mu0(i,1)=Mu0(i,1)+meanAll; % add mean value of the observed instead of zero
%                 else % if observed
%                     Mu0(i,1)=Mu0(i,1)+PriorODMean(j,1); % add obseved mean flow
%                 end
%             end
%         end
        % True and prior std.dev by choosing a link
        Sigma(i,1)=(TrUncorr(:,3)').^2*ODChoiceIndUncorr(:,i)+diag(TrCorrCov)'*ODChoiceIndCorr(:,i);
%         Sigma(i,1)=(TrueODStdev').^2*ODChoiceInd(:,i);    % truth
        Sigma0(i,1)=(PrUncorr(:,3)').^2*ODChoiceIndUncorr(:,i)+diag(PrCorrCov)'*ODChoiceIndCorr(:,i);
%         Sigma0(i,1)=(PriorODStdev').^2*ODChoiceInd(:,i);  % prior
    end

    % DIFFERENT LEARNING POLICIES FOR LINKE EXTENSIONS
    if mabsetting==1 % Multi-armed bandit policy (MAB)
        [Mu_est, OC, Choices, ObsOD, PrUncorr, PrCorrMean,PrecisU,PrecisC]=Example_mab_transfer_20220801(Mu,Mu0,M,ObsOD,ODChoice,ODSystemNet,PrUncorr,TrUncorr,PrCorrMean,TrCorrMean,TrCorrCov,PrecisU,PrecisC);
    elseif kggeneral==1 % Knowledge gradient policy (KG)
        [Mu_est, OC, Choices, ObsOD, PrUncorr, PrCorrMean,PrecisU,PrecisC]=Example_kg_transfer_20220801(Mu,Mu0,Sigma,Sigma0,M,ObsOD,ODChoice,ODSystemNet,PrUncorr,TrUncorr,PrCorrMean,TrCorrMean,TrCorrCov,PrecisU,PrecisC);
    else % Knowledge gradient with correlated belief policy (KGCB)
        [Mu_est, OC, Choices, Mu_estALL, ObsOD, PrUncorr, PrCorrMean, PrCorrCov,PrecisU,PrecisC]=Example_kgcb_PUMA_transfer_20220801(Mu,Mu0,M,ObsOD,ODChoice,ODSystemNet,PrUncorr,TrUncorr,PrCorrMean,PrCorrCov,TrCorrMean,TrCorrCov,FlowCluster,ODChoiceIndCorr,PrecisU,PrecisC);
    end
    [~,I]=max(Mu_est);  % choice with the largest estimated flow
    nextLink=LinkChoice1(I);        % chosen link
    nextNode=setdiff(EdgeInfo(2:3,nextLink),NodeSystemNet);  % chosen node
    [~,I2]=max(Mu);     % choice with the largest true flow
    
    
    % UPDATE NODE ARCHIVE
    NodeRoute=[NodeRoute,nextNode];                 % attach new node
    Result(nSim+1).Route(RT).NodeRoute=NodeRoute;	% archive to Result
    NodeRouteList{NodeRoute(end),2}=RT;             % update incidence between node and route
    NodeSystemNet=[NodeSystemNet,nextNode];         % archive to NodeSystemNet
    
    % UPDATE OD PAIR ARCHIVE
    ODSystemNet=ODChoice{1,I};          % total covered OD
    ODSystemNetIndUncorr=ODChoiceIndUncorr(:,I);    % total covered OD (indexed)
    ODSystemNetIndCorr=ODChoiceIndCorr(:,I);    % total covered OD (indexed)
    
    % UPDATE OPPORTUNITY COST ARCHIVE
    OppCost{2,1}=RT;        % route ID
    OppCost{2,2}=nextNode;  % chosen node
    OppCost{2,3}=I;         % choice made
    OppCost{2,4}=I2;        % true best
    OppCost{2,5}=OC;        % opportunity cost
    
    % UPDATE LINK ARCHIVE
    IncludedLink=[IncludedLink,RemainingLink(:,RemainingLink(1,:)==nextLink)];	% add chosen link pair
    RemainingLink(:,RemainingLink(1,:)==nextLink)=[]; % delete chosen link pair
    IncludedLink=sortrows(IncludedLink')';  % sort included links              
    
    % VIRTUAL NETWORK SHOULD BE CREATED FOR TRAVEL TIME CALCULATION WITH TRANSFER LATER
    
    %% REPEAT LINK-LEVEL EXTENSION UNTIL CRITERIA ARE MET
    while length(NodeRoute)<maxL % # of nodes < maximum #
        % CANDIDATE LINKS FROM BOTH ROUTE ENDS
        LinkChoice2=[RemainingLink(1,RemainingLink(2,:)==NodeRoute(1)|RemainingLink(2,:)==NodeRoute(end)),RemainingLink(1,RemainingLink(3,:)==NodeRoute(1)|RemainingLink(3,:)==NodeRoute(end))]; % create next round candidates from remaining links
        nCandLink=size(LinkChoice2,2);  % # of options
        % DELETE LINKS ALREADY COVERED BY CURRENT ROUTE
        for i=1:nCandLink
            if sum(ismember(EdgeInfo(2:3,LinkChoice2(nCandLink-i+1))',NodeRoute))==2
                LinkChoice2(nCandLink-i+1)=[]; % inversely indexed to avoid error
            end
        end
        
        % EVALUATE LINKS BASED ON COLLECTED INFORMATION (ASSUMED) 
        % Only look into available links, not the entire network
        nCandLink=size(LinkChoice2,2);
        ODChoice=cell(1,nCandLink);
%         ODChoiceInd=zeros(nOD,nCandLink);
        ODChoiceIndUncorr=zeros(nUncorrFlow,nCandLink);
        ODChoiceIndCorr=zeros(nCorrFlow,nCandLink);
        for i=1:nCandLink
            ODChoice{1,i}=ODSystemNet;          % load previously included OD pairs
            ODChoiceIndUncorr(:,i)=ODSystemNetIndUncorr;    % load indicators of ODs that covered by choices
            ODChoiceIndCorr(:,i)=ODSystemNetIndCorr;
        end
        
        Mu=zeros(nCandLink,1);
        Mu0=zeros(nCandLink,1);
        Sigma=zeros(nCandLink,1);
        Sigma0=zeros(nCandLink,1);
        
        for i=1:nCandLink
            % IDENTIFY OD PAIRS NEWLY AVAILABLE PER CHOICE
            % Create from existing nodes
            ODTemp=NodeSystemNet';  % nodes included previously
            ODTemp(:,end+1)=setdiff(EdgeInfo(2:3,LinkChoice2(i)),NodeSystemNet); % pair with end node of new link (possible new node to the system)
            ODTemp=unique(sort(ODTemp,2,'ascend'),'rows');           % delete duplicates
            ODFLOWIDTemp=zeros(size(ODTemp,1),1);	% array for ODflowID
            for j=1:size(ODTemp,1)
                [~,ODFLOWIDTemp(j,1)]=ismember(ODTemp(j,:),PUMAinfo(:,2:3),'rows'); % find ODflowID
            end
            ODFLOWIDTemp(ODFLOWIDTemp(:,1)==0,:)=[]; % exclude OD pairs does not exist
            ODChoice{1,i}=[ODChoice{1,i},ODFLOWIDTemp']; % attach new OD pairs to ODChoice
            ODChoice{1,i}=unique(ODChoice{1,i}); % delete duplicates
            for j=1:size(ODChoice{1,i},2)
%                 ODChoiceInd(ODChoice{1,i}(j),i)=1;   % update indicators between OD pair and choice
                if ismember(ODChoice{1,i}(j),PrCorrMean(:,1)) % correlated
                    ODChoiceIndCorr(PrCorrMean(:,1)==ODChoice{1,i}(j),i)=1;
                else
                    ODChoiceIndUncorr(PrUncorr(:,1)==ODChoice{1,i}(j),i)=1;
                end
            end

            % PREPARE FUNCTION INPUTS
%             Mu(i,1)=TrueODMean'*ODChoiceInd(:,i); % true mean flow by choosing a link
            Mu(i,1)=TrUncorr(:,2)'*ODChoiceIndUncorr(:,i)+TrCorrMean(:,2)'*ODChoiceIndCorr(:,i);
            % #3 Mean of all observed OD flows
%             Pom=PriorODMean(:,1);
%             meanAll=mean(Pom(Pom>0));
            AllMeans=[PrCorrMean(:,2);PrUncorr(:,2)];
            meanAll=mean(AllMeans(AllMeans>0));
%             for j=1:nOD
%                 if ODChoiceInd(j,i)>0
%                     if PriorODMean(j,1)==0
%                         Mu0(i,1)=Mu0(i,1)+meanAll; % #3 mean of all observed values
%                     else 
%                         Mu0(i,1)=Mu0(i,1)+PriorODMean(j,1);
%                     end
%                 end
%             end
            for j=1:nUncorrFlow
                if ODChoiceIndUncorr(j,i)>0 % j-th flow is covered by i-th choice
                    if PrUncorr(j,2)==0 % if not observed
                        Mu0(i,1)=Mu0(i,1)+meanAll; % add mean value of the observed instead of zero
                    else % if observed
                        Mu0(i,1)=Mu0(i,1)+PrUncorr(j,2); % add obseved mean flow
                    end
                end
            end
            for j=1:nCorrFlow
                if ODChoiceIndCorr(j,i)>0 % j-th flow is covered by i-th choice
                    if PrCorrMean(j,2)==0 % if not observed
                        Mu0(i,1)=Mu0(i,1)+meanAll; % add mean value of the observed instead of zero
                    else % if observed
                        Mu0(i,1)=Mu0(i,1)+PrCorrMean(j,2); % add obseved mean flow
                    end
                end
            end
%             Sigma(i,1)=(TrueODStdev').^2*ODChoiceInd(:,i);    % true std.dev by choosing a link
%             Sigma0(i,1)=(PriorODStdev').^2*ODChoiceInd(:,i);  % std.dev by based on prior
            Sigma(i,1)=(TrUncorr(:,3)').^2*ODChoiceIndUncorr(:,i)+diag(TrCorrCov)'*ODChoiceIndCorr(:,i);
            Sigma0(i,1)=(PrUncorr(:,3)').^2*ODChoiceIndUncorr(:,i)+diag(PrCorrCov)'*ODChoiceIndCorr(:,i);
        end
        
        % LEARNING PROCEDURE
        if mabsetting==1 % Multi-armed bandit
%             [Mu_est2, OC2, Choices2, ObsOD, PriorODMean, PriorODStdev]=Example_mab_transfer_20220620(Mu,Mu0,M,ObsOD,PriorODMean,PriorODStdev,ODChoice,ODSystemNet,TrueODMean,TrueODStdev,TrueCov,CorFlow2);
            [Mu_est2, OC2, Choices2, ObsOD, PrUncorr, PrCorrMean,PrecisU,PrecisC]=Example_mab_transfer_20220801(Mu,Mu0,M,ObsOD,ODChoice,ODSystemNet,PrUncorr,TrUncorr,PrCorrMean,TrCorrMean,TrCorrCov,PrecisU,PrecisC);
        elseif kggeneral==1 % Knowledge gradient
%             [Mu_est2, OC2, Choices2, ObsOD, PriorODMean, PriorODStdev]=Example_kg_transfer_20220620(Mu,Mu0,Sigma,Sigma0,M,ObsOD,PriorODMean,PriorODStdev,ODChoice,ODSystemNet,TrueODMean,TrueODStdev,TrueCov,CorFlow2);
            [Mu_est2, OC2, Choices2, ObsOD, PrUncorr, PrCorrMean,PrecisU,PrecisC]=Example_kg_transfer_20220801(Mu,Mu0,Sigma,Sigma0,M,ObsOD,ODChoice,ODSystemNet,PrUncorr,TrUncorr,PrCorrMean,TrCorrMean,TrCorrCov,PrecisU,PrecisC);
        else % Knowledge gradient with correlated belief
%             [Mu_est2, OC2, Choices2, Mu_estALL2, ObsOD, CovOD, PriorODMean]=Example_kgcb_PUMA_transfer_20220620(Mu,Mu0,M,ObsOD,CovOD,PriorODMean,ODChoice,ODSystemNet,TrueODMean,TrueODStdev,PUMAODinfo2,TrueCov,CorFlow2);
            [Mu_est2, OC2, Choices2, Mu_estALL2, ObsOD, PrUncorr, PrCorrMean, PrCorrCov,PrecisU,PrecisC]=Example_kgcb_PUMA_transfer_20220801(Mu,Mu0,M,ObsOD,ODChoice,ODSystemNet,PrUncorr,TrUncorr,PrCorrMean,PrCorrCov,TrCorrMean,TrCorrCov,FlowCluster,ODChoiceIndCorr,PrecisU,PrecisC);
        end
        
        [~,II]=max(Mu_est2);    % choose the link with the largest estimated flow
        [~,II2]=max(Mu);        % chosen link
        nextLink=LinkChoice2(II);
        nextNode=setdiff(EdgeInfo(2:3,nextLink),NodeSystemNet);   % chosen node
        
        % UPDATE NODE ARCHIVE
        ATT=EdgeInfo(2:3,nextLink)==NodeRoute(end);
        if sum(ATT)==1
            NodeRoute=[NodeRoute,nextNode];   % in a sequence of connection
%             [EdgeInfo(2:3,nextLink)';NodeRoute(end-1:end)]
        else
            NodeRoute=[nextNode,NodeRoute];  % extend in the opposite direction
%             [EdgeInfo(2:3,nextLink)';NodeRoute(1:2)]
        end
%         if NodeRoute(end)==EdgeInfo(2,nextLink)
%             NodeRoute=[NodeRoute,nextNode];   % in a sequence of connection
%         else
%             NodeRoute=[nextNode,NodeRoute];  % extend in the opposite direction
%         end
        NodeRouteList{nextNode,2}=RT;   % indicate current
        Result(nSim+1).Route(RT).NodeRoute=NodeRoute; % update NodeRoute
        NodeSystemNet=NodeRoute; % update NodeSystemNet (equivalent only for 1st route)
        
        % UPDATE OPPORTUNITY COST ARCHIVE
        OppCost{length(NodeRoute),1}=RT;
        OppCost{length(NodeRoute),2}=nextNode;
        OppCost{length(NodeRoute),3}=II;
        OppCost{length(NodeRoute),4}=II2;
        OppCost{length(NodeRoute),5}=OC2;
        
        % UPDATE LINK ARCHIVE
        IncludedLink=[IncludedLink,RemainingLink(:,RemainingLink(1,:)==nextLink)];	% add chosen link pair
        RemainingLink(:,RemainingLink(1,:)==nextLink)=[]; % delete chosen link pair
        IncludedLink=sortrows(IncludedLink')';  % sort included links
        
        % UPDATE OD PAIR ARCHIVE
        ODSystemNet=ODChoice{1,II};
        ODSystemNetIndUncorr=ODChoiceIndUncorr(:,II);    % total covered OD (indexed)
        ODSystemNetIndCorr=ODChoiceIndCorr(:,II);
    end
    
    EstMeanODFlow=[EstMeanODFlow,[PrUncorr(:,1:2);PrCorrMean(:,1:2)]];
    Result(nSim+1).ServingOD{RT,1}=ODSystemNet;
    OPPCOST=[OPPCOST;OppCost];
%     RT
    
    %% PREPARE TRANSFER INFORMATION (NODE COVERAGE)
    % 1. Relationship between routes: transferable?
    % 2. Transfer node: intersections
    % 3. Available OD pairs: either choice- or route-level
    
    % COVERED OD PAIRS PER ROUTE PAIR
    ODwithRTpair=cell(nReqRoute); % each cell will have OD pairs covered by i-/j-th routes
    ODwithRTpair{1,1}=Result(nSim+1).ServingOD{RT,1}; % result of 1st route    
    
    %% SUBSEQUENT ROUTES (RT>1)
    for RT = 2:nReqRoute
        % NODES COVERED BY CURRENT NETWORK
        % When RT>1: nodes and links of previous routes
        
        %{
        FOR EVERY 1ST EXTENSION, THE ALGORITHM SHOULD INVESTIGATE:
        1. IS A NODE COVERED BY ANY OTHER ROUTES?
           -> YES: 2, NO: CASE I
        2. DOES A ROUTE ALREADY INTERSECT WITH CURRENT ONE?
           -> YES: CASE II, NO: CASE III
        
        CASE I: GENERAL NODE
                AVAILABLE NEW OD PAIRS: BETWEEN NODE AND CONNECTABLE ROUTES
        CASE II: COVERED AND ACCESSIBLE NODE
                AVAILABLE NEW OD PAIRS: NONE
        CASE III: COVERED BUT INACCESSIBLE NODE
                AVAILABLE NEW OD PAIRS: BETWEEN CURRENT ROUTE AND NEW ONE
        %}
        
        OppCost=cell(maxL,5);
        OppCost{1,1}=RT;
        % LARGEST IN- AND OUTFLOW TO ALL OTHER NODES & SUBTRACT COVERED : REMAINING OD FLOWS
        % Identify potential links to extend
        CandStartNode = NodeSystemNet;      % all existing nodes can be candidates
        nCandStart = size(CandStartNode,2); % # of candidates 
        
        % FIND THE EXISTING NODE WITH THE LARGEST REMAINING FLOW
        NNF1=zeros(1,nCandStart); % net flow per candidate node
%         INITIAL VERSION        
        for i=1:nCandStart
            PairsU=setdiff(PairperNode{CandStartNode(i),1},ODSystemNet); % uncorrelated pairs
            PairsC=setdiff(PairperNode{CandStartNode(i),2},ODSystemNet); % correlated pairs
            for j=1:length(PairsU)
                NNF1(i)=NNF1(i)+PrUncorr(PrUncorr(:,1)==PairsU(j),2);
            end
            for j=1:length(PairsC)
                NNF1(i)=NNF1(i)+PrCorrMean(PrCorrMean(:,1)==PairsC(j),2);
            end
%             NNF1(1,i)=sum(PriorODMean(PUMAinfo(:,2)==CandStartNode(i),1))+sum(PriorODMean(PUMAinfo(:,3)==CandStartNode(i),1)); % aggregate all OD flows from/to i-th node
        end
%         for i=1:size(ODSystemNet,2)
%             iOD=ODSystemNet(i);  % i-th served OD
%             if ismember(PUMAODinfo2(iOD,2),CandStartNode)
%                 NNF1(1,CandStartNode==PUMAODinfo2(iOD,2))=NNF1(1,CandStartNode==PUMAODinfo2(iOD,2))-PriorODMean(iOD,1); % deduct OD flow of i-th served OD from net flow of i
%             end
%             if ismember(PUMAODinfo2(iOD,3),CandStartNode)
%                 NNF1(1,CandStartNode==PUMAODinfo2(iOD,3))=NNF1(1,CandStartNode==PUMAODinfo2(iOD,3))-PriorODMean(iOD,1); % deduct OD flow of i-th served OD from net flow of j
%             end
%         end
        
        % TESTING ALTERNATIVE 1 OF DESIGNATING INITIAL POINT
%         for i=1:nCandStart
%             ni=CandStartNode(i);
%             for j=1:length(ReachableNodes{ni,5})
%                 [~,loc1]=ismember([ni,ReachableNodes{ni,5}(j)],PUMAODinfo2(:,2:3),'rows');
%                 if ismember(loc1,ODSystemNet)
%                     NodeNetFlow(1,i)=NodeNetFlow(1,i)+PriorODMean(loc1,1);
%                 end
%                 [~,loc2]=ismember([ReachableNodes{ni,5}(j),ni],PUMAODinfo2(:,2:3),'rows');
%                 if ismember(loc2,ODSystemNet)
%                     NodeNetFlow(1,i)=NodeNetFlow(1,i)+PriorODMean(loc2,1);
%                 end
%             end
%         end
        
        % THIS SHOULD BE MODIFIED TO IMPLEMENT MULTIPLE NODE CONSIDERATION
        % Current: compare total remaining in- and outflow of nodes and
        %          choose the one with the best. skip to the next largest
        %          if no adjacent nodes are vacant.
        % New: compare sum of total remaining in- and outflow of a pair of
        %      included node and its neighbor. choose the one with the best
        %      unless both nodes are already covered. if so, skip to the
        %      next pair.
        
        % NEW PART: Include adjacent node
        NNF2=zeros(1,4);
        k=0;
        for i=1:nCandStart
            RN=ReachableNodes{CandStartNode(i),2};
            for j=1:length(RN)
                % Exclude 2nd nodes without vacant adjacent nodes
                if sum(setdiff(ReachableNodes{RN(j),2},NodeSystemNet))>0
                    k=k+1;
                    NNF2(k,1:3)=[CandStartNode(i),RN(j),NNF1(i)];
                    PairsU=setdiff(PairperNode{RN(j),1},ODSystemNet); % uncorrelated pairs
                    PairsC=setdiff(PairperNode{RN(j),2},ODSystemNet); % correlated pairs
                    for m=1:length(PairsU)
                        NNF2(k,4)=NNF2(k,4)+PrUncorr(PrUncorr(:,1)==PairsU(m),2);
                    end
                    for m=1:length(PairsC)
                        NNF2(k,4)=NNF2(k,4)+PrCorrMean(PrCorrMean(:,1)==PairsC(m),2);
                    end
                    edgeDup=intersect(PairperNode{RN(j),1},PairperNode{CandStartNode(i),1});
                    if ~ismember(edgeDup,ODSystemNet)
                        if edgeDup>0
                            NNF2(k,4)=NNF2(k,4)-PrUncorr(PrUncorr(:,1)==edgeDup,2);
                        else
                            edgeDup=intersect(PairperNode{RN(j),2},PairperNode{CandStartNode(i),2});
                            NNF2(k,4)=NNF2(k,4)-PrCorrMean(PrCorrMean(:,1)==edgeDup,2);
                        end
                    end
                end
            end
        end
        
%         for i=1:size(ODSystemNet,2)
%             iOD=ODSystemNet(i);  % i-th served OD
%             NNF2(NNF2(:,2)==PUMAODinfo2(iOD,2),4)=NNF2(NNF2(:,2)==PUMAODinfo2(iOD,2),4)-PriorODMean(iOD,1);
%             NNF2(NNF2(:,2)==PUMAODinfo2(iOD,3),4)=NNF2(NNF2(:,2)==PUMAODinfo2(iOD,3),4)-PriorODMean(iOD,1);
%         end
        NNF2(:,5)=sum(NNF2(:,3:4),2);
        
        NodeNetFlow=NNF2(:,5)';
        [~,maxSet]=max(NodeNetFlow);
        StartNodeSet=NNF2(maxSet,1:2);
        start=StartNodeSet(1);
        nextNode=StartNodeSet(2);
        SNS=sort(StartNodeSet);
        [~,nextLink]=ismember(SNS,EdgeInfo(2:3,:)','rows');
        
%         % IDENTIFY IF "maxNode" IS FEASIBLE (CASE I OR III)
%         % : available to be connected to at least one adjacent node
%         indnode1st=0;   % indicator of designating initial node (1: desginated)
%         while indnode1st==0
%             [~,maxNode]=max(NodeNetFlow(:));	% location of node with maximum net flow
%             start=CandStartNode(maxNode);       % temporary initial node
%             LinkInfoformaxNode=LinkInfo(:,LinkInfo(2,:)==start);    % links that start from "start"
%             RTStartA=NodeRouteList{start,2};    % routes covering "start"
%             nRT_A=length(RTStartA);             % # of routes covering "start"
%             nAdjLinksfromMax=size(LinkInfoformaxNode,2);	% # of adjacent links from "start"
%             
%             % VERIFY IF "start" IS APPROPRIATE FOR INITIAL NODE
%             for i=1:nAdjLinksfromMax
%                 RTStartB=NodeRouteList{LinkInfoformaxNode(3,i),2}; % routes covering opposite end of link
%                 nRT_B=length(RTStartB); % # of routes covering opposite end of link
%                 % Classification of link case
%                 if nRT_B==0 % no routes covering opposite end
%                     indnode1st=1; % CASE I LINK: MAKE THIS NODE FEASIBLE
%                     break
%                 else % nRT_B>0
%                     indintrsct=0;   % indicator of intersecting routes
%                     % Investigate all route pairs of RTStartA and RTStartB
%                     % to check if they already intersect at somewhere else:
%                     % If do, these nodes are already connectable with
%                     % existing system.
%                     for j=1:nRT_A
%                         for k=1:nRT_B
%                             indintrsct=indintrsct+RTintsct(RTStartA(j),RTStartB(k));
%                             if indintrsct>0 % At least a pair of routes can connect "start" and candidate node
%                                 break % CASE II LINK: MAKE THIS NODE INFEASIBLE
%                             end   
%                         end
%                         if indintrsct>0
%                             break
%                         end
%                     end
%                     if indintrsct==0 % no route pair connects "start" and candidate node
%                         indnode1st=1; % CASE III LINK: MAKE THIS NODE FEASIBLE
%                     end
%                 end
%             end
%             if indnode1st==0
%                 NodeNetFlow(maxNode)=0;
%             end
%         end
        
        % CHOSEN NODE: "start"
        NodeRoute=start;	% add this node to route
        NodeSystemNet=unique([NodeSystemNet,start]); % update total nodes in the system
        OppCost{1,2}=start; % 1st choice is "start"
        Result(nSim+1).Route(RT).NodeRoute=start;   % add "start" to Rt-th route as 1st node
        NodeRouteList{start,2}=unique([NodeRouteList{start,2},RT]); % update routes visiting "start"
        RTStartA=NodeRouteList{start,2};    % update "RTStartA"
        nRT_A=length(RTStartA); % # of routes serving "start"
        for i=1:nRT_A
            RTintsct(RTStartA(i),RT)=1; % update RTintsct since routes in RTStartA intersect with RT
        end
        
%         % NEW PART
%         NodeRoute=StartNodeSet;
%         NodeSystemNet=unique([NodeSystemNet,NodeRoute]);
%         OppCost{1,2}=start;
%         OppCost{2,2}=nextNode;
%         Result(nSim+1).Route(RT).NodeRoute=NodeRoute;
%         NodeRouteList{start,2}=unique([NodeRouteList{start,2},RT]);
%         NodeRouteList{nextNode,2}=unique([NodeRouteList{nextNode,2},RT]);
%         RTStartA=NodeRouteList{start,2};
%         RTStartB=NodeRouteList{nextNode,2};
%         nRT_A=length(RTStartA);
%         for i=1:nRT_A
%             RTintsct(RTStartA(i),RT)=1;
%         end

        % WE NEED TO IDENTIFY WHICH OD PAIRS ARE ACTIVATED WHEN CHOOSING A
        % LINK AMONG AVAILABLE ONES
%         LinkChoice1=LinkInfo(:,LinkInfo(2,:)==start); % links that start from "start"
%         LinkChoice1=LinkInfo(:,LinkInfo(2,:)==start&LinkInfo(3,:)==nextNode);
        LinkChoice1=EdgeInfo(:,nextLink);
        nCandLink=size(LinkChoice1,2);      % # of available links
        ODChoice=cell(1,nCandLink);    % [total OD covered]
%         ODChoiceInd=zeros(nOD,nCandLink); % indicate ODs that covered by choices
        ODChoiceIndUncorr=zeros(nUncorrFlow,nCandLink);
        ODChoiceIndCorr=zeros(nCorrFlow,nCandLink);
%         for i=1:nCandLink
%             ODChoiceInd(:,i)=ODSystemNetInd;
%         end
        for i=1:nCandLink
            ODChoice{1,i}=ODSystemNet;          % load previously included OD pairs
            ODChoiceIndUncorr(:,i)=ODSystemNetIndUncorr;    % load indicators of ODs that covered by choices
            ODChoiceIndCorr(:,i)=ODSystemNetIndCorr;
        end

        Mu=zeros(nCandLink,1);      % prepare mean flow based on truth
        Mu0=zeros(nCandLink,1);     % prepare mean flow based on prior
        Sigma=zeros(nCandLink,1);	% prepare std.dev of flow based on truth
        Sigma0=zeros(nCandLink,1);	% prepare std.dev of flow based on prior
        
        % IDENTIFY OD FLOWS INVOLVED IN OPTIONS
        for i=1:nCandLink
            ODTemp=[];	% temporary space for total new OD flows from choosing i
            ODTemp2=[]; % from routes serving "start" to opposite end of link
            ODTemp3=[]; % from "start" to routes serving opposite end of link
            RTStartB=NodeRouteList{LinkChoice1(3,i),2}; % routes covering opposite end of link
            nRT_B=length(RTStartB); % # of routes covering opposite end of link
            
            % CLASSIFICATION OF LINK CASE
            % Case I: new OD pairs are generated between new node and 
            %         existing transferable routes (RTintsct(:,RT)==1)
            % Case II: infeasible
            % Case III: new OD pairs are generated between
            %           1) A and route covering B and not accessible from A
            %           2) B and route covering A and not accessible from B
            
            % Regardless of link case, routes serving "start" and opposite end must be connected
            for j=1:nRT_A
                % NEW OD PAIRS: BETWEEN NEW NODE(B) AND NODES IN "RTStartA"
                ODTemp2=Result(nSim+1).Route(RTStartA(j)).NodeRoute'; % nodes included in j-th route
                snode=setdiff(LinkChoice1(2:3,i)',ODTemp2);
                if snode>0
                    ODTemp2(:,2)=snode;
%                 ODTemp2=[ODTemp2;ODTemp2(:,2:-1:1)];
                    ODTemp=[ODTemp;ODTemp2];
                end
            end
            
            % If i-th link is Case III, it should consider connections between "start" and routes serving opposite end
            if nRT_B>0 % there exist routes covering opposite end
                for j=1:nRT_B
                    % NEW OD PAIRS: BETWEEN "start" AND NODES IN "RTStartB"
                    ODTemp3=Result(nSim+1).Route(RTStartB(j)).NodeRoute'; % nodes included in j-th route
                    snode=setdiff(LinkChoice1(2:3,i)',ODTemp3);
                    if snode>0
                        ODTemp3(:,2)=snode;
%                     ODTemp3=[ODTemp3;ODTemp3(:,2:-1:1)];
                        ODTemp=[ODTemp;ODTemp3];
                    end
                end
            end
            ODTemp=unique(ODTemp,'rows');           % All unique OD pairs (i,j) of choice
            ODTemp=sort(ODTemp,2);
            ODFLOWIDTemp=zeros(size(ODTemp,1),1);   % Convert (i,j) to ODflowID
            for j=1:size(ODTemp,1)
                [~,ODFLOWIDTemp(j,1)]=ismember(ODTemp(j,:),PUMAinfo(:,2:3),'rows');
            end
            ODFLOWIDTemp(ODFLOWIDTemp(:,1)==0,:)=[];    % delete empty rows
            ODChoice{1,i}=ODFLOWIDTemp';   % ODs covered by choice
            ODChoice{1,i}=setdiff(ODChoice{1,i},ODSystemNet);
            
            for j=1:size(ODChoice{1,i},2)
%                 ODChoiceInd(ODChoice{1,i}(j),i)=1;   % Add newly covered ODs
                if ismember(ODChoice{1,i}(j),PrCorrMean(:,1)) % correlated
                    ODChoiceIndCorr(PrCorrMean(:,1)==ODChoice{1,i}(j),i)=1;
                else
                    ODChoiceIndUncorr(PrUncorr(:,1)==ODChoice{1,i}(j),i)=1;
                end
            end
            % PREPARE FUNCTION INPUTS
%             Mu(i,1)=TrueODMean'*ODChoiceInd(:,i); % true mean flow by choosing a link
            Mu(i,1)=TrUncorr(:,2)'*ODChoiceIndUncorr(:,i)+TrCorrMean(:,2)'*ODChoiceIndCorr(:,i);
            % #3 Mean of all observed OD flows
%             Pom=PriorODMean(:,1);
%             meanAll=mean(Pom(Pom>0));
            AllMeans=[PrCorrMean(:,2);PrUncorr(:,2)];
            meanAll=mean(AllMeans(AllMeans>0));
            for j=1:nUncorrFlow
                if ODChoiceIndUncorr(j,i)>0 % j-th flow is covered by i-th choice
                    if PrUncorr(j,2)==0 % if not observed
                        Mu0(i,1)=Mu0(i,1)+meanAll; % add mean value of the observed instead of zero
                    else % if observed
                        Mu0(i,1)=Mu0(i,1)+PrUncorr(j,2); % add obseved mean flow
                    end
                end
            end
            for j=1:nCorrFlow
                if ODChoiceIndCorr(j,i)>0 % j-th flow is covered by i-th choice
                    if PrCorrMean(j,2)==0 % if not observed
                        Mu0(i,1)=Mu0(i,1)+meanAll; % add mean value of the observed instead of zero
                    else % if observed
                        Mu0(i,1)=Mu0(i,1)+PrCorrMean(j,2); % add obseved mean flow
                    end
                end
            end
%             for j=1:nOD
%                 if ODChoiceInd(j,i)>0
%                     if PriorODMean(j,1)==0
%                         Mu0(i,1)=Mu0(i,1)+meanAll; % #3 mean of all observed values
%                     else 
%                         Mu0(i,1)=Mu0(i,1)+PriorODMean(j,1);
%                     end
%                 end
%             end
%             Sigma(i,1)=(TrueODStdev').^2*ODChoiceInd(:,i);    % true std.dev by choosing a link
%             Sigma0(i,1)=(PriorODStdev').^2*ODChoiceInd(:,i);  % std.dev by based on prior
            Sigma(i,1)=(TrUncorr(:,3)').^2*ODChoiceIndUncorr(:,i)+diag(TrCorrCov)'*ODChoiceIndCorr(:,i);
            Sigma0(i,1)=(PrUncorr(:,3)').^2*ODChoiceIndUncorr(:,i)+diag(PrCorrCov)'*ODChoiceIndCorr(:,i);
        end
        
%         % IDENTIFY THE BEST CHOICE
%         % If there is any link, the code evaluates them
%         if sum(Mu)>0
%             for i=1:nCandLink
%                 if Mu(nCandLink-i+1,1)==0
%                     LinkChoice1(:,nCandLink-i+1)=[];
%                     Mu(nCandLink-i+1,:)=[];
%                     Mu0(nCandLink-i+1,:)=[];
%                     ODChoice(:,nCandLink-i+1)=[];
%                 end
%             end
%             M=10; % # of observations for one-link extension, should be greater than number of choices
%             if mabsetting==1 % Multi-armed bandit
%                 [Mu_est, OC, Choices, ObsOD, PriorODMean, PriorODStdev]=Example_mab_transfer_20220620(Mu,Mu0,M,ObsOD,PriorODMean,PriorODStdev,ODChoice,ODSystemNet,TrueODMean,TrueODCov);
%             elseif kggeneral==1 % Knowledge gradient
%                 [Mu_est, OC, Choices, ObsOD, PriorODMean, PriorODStdev]=Example_kg_transfer_20220620(Mu,Mu0,Sigma,Sigma0,M,ObsOD,PriorODMean,PriorODStdev,ODChoice,ODSystemNet,TrueODMean,TrueODStdev,TrueODCov);
%             else % Knowledge gradient with correlated belief
%                 [Mu_est, OC, Choices, Mu_estALL, ObsOD, CovOD, PriorODMean]=Example_kgcb_PUMA_transfer_20220620(Mu,Mu0,M,ObsOD,CovOD,PriorODMean,ODChoice,ODSystemNet,TrueODMean,TrueODStdev,PUMAODinfo2,CorrGroup,Covar,CorrFlowList);
%             end
%             [~,I]=max(Mu_est);
%             [~,I2]=max(Mu);
%         else
%             assert(sum(Mu)==0,'No links improve the system', sum(Mu))
%             I=randi(nCandLink);
%             I2=0;
%         end
        
        % NEW LINE
        I=1;

        IncludedLink=[];
%         RemainingLink=LinkInfo;
        
%         nextLink=LinkChoice1(1,I);
%         nextNode=LinkChoice1(3,I);
        
        NodeRouteList{nextNode,2}=RT;   % indicate current
%         Result(nSim+1).Route(RT).NodeRoute=NodeRoute; % update NodeRoute
%         NodeSystemNet=NodeRoute; % update NodeSystemNet (equivalent only for 1st route)
        
        NodeSystemNet=unique([NodeSystemNet,nextNode]);
        NodeRoute=[NodeRoute,nextNode];   % in a sequence of connection
        Result(nSim+1).Route(RT).NodeRoute=NodeRoute;
        NodeRouteList{NodeRoute(end),2}=[NodeRouteList{NodeRoute(end),2},RT];

        ODSystemNet = unique([ODSystemNet,ODChoice{I}]);
%         ODSystemNetInd=ODChoiceInd(:,I);        
        ODSystemNetIndUncorr=ODChoiceIndUncorr(:,I);    % total covered OD (indexed)
        ODSystemNetIndCorr=ODChoiceIndCorr(:,I);    % total covered OD (indexed)
%         OppCost{2,1}=RT;
        OppCost{2,2}=nextNode;
%         OppCost{2,3}=I;
%         OppCost{2,4}=I2;
%         OppCost{2,5}=OC;
        
%         RTStartB=NodeRouteList{nextNode,2}; % routes covering opposite end of link
%         nRT_B=length(RTStartB);
%         for i=1:nRT_B
%             RTintsct(RTStartB(i),RT)=1;
%         end
        
        for i=1:RT
            ODTemp=[];
            if RTintsct(i,RT)==1
                ODTemp=Result(nSim+1).Route(i).NodeRoute';
                ODTemp(:,2)= nextNode;
%                 ODTemp=[ODTemp;ODTemp(:,2:-1:1)];
            end
            ODTemp=unique(ODTemp,'rows');           % All unique OD pairs (i,j) of choice
            ODTemp=sort(ODTemp,2);
            ODFLOWIDTemp=zeros(size(ODTemp,1),1);   % Convert (i,j) to ODflowID
            for j=1:size(ODTemp,1)
                [~,ODFLOWIDTemp(j,1)]=ismember(ODTemp(j,:),PUMAinfo(:,2:3),'rows');
            end

            ODFLOWIDTemp(ODFLOWIDTemp(:,1)==0,:)=[];
            ODwithRTpair{i,RT}=[ODwithRTpair{i,RT},ODFLOWIDTemp'];
        end 
        
%         IncludedLink=[IncludedLink,RemainingLink(:,RemainingLink(1,:)==nextLink)];
%         RemainingLink(:,RemainingLink(1,:)==nextLink)=[];
        
        % UPDATE LINK ARCHIVE
        IncludedLink=[IncludedLink,RemainingLink(:,RemainingLink(1,:)==nextLink)];	% add chosen link pair
        RemainingLink(:,RemainingLink(1,:)==nextLink)=[]; % delete chosen link pair
        IncludedLink=sortrows(IncludedLink')';  % sort included links
        
%         if mod(LinkChoice1(1,I),2)==0 % link ID is even
%             IncludedLink=[IncludedLink,RemainingLink(:,RemainingLink(1,:)==(LinkChoice1(1,I)-1))];
%             RemainingLink(:,RemainingLink(1,:)==(LinkChoice1(1,I)-1))=[];
%         else % link ID is odd
%             IncludedLink=[IncludedLink,RemainingLink(:,RemainingLink(1,:)==(LinkChoice1(1,I)+1))];
%             RemainingLink(:,RemainingLink(1,:)==(LinkChoice1(1,I)+1))=[];
%         end
%         RLS=sortrows(IncludedLink');
%         IncludedLink=RLS';
        
        for i=1:RT
            K=[];
            for j=1:length(Result(nSim+1).Route(i).NodeRoute)
                K=[K,NodeRouteList{Result(nSim+1).Route(i).NodeRoute(j),2}];
            end
            RTGroups{i,2}=unique(K);            
        end
        
        %% UPDATE COVARIANCE OF OD AND LINK (in Function "Example_kgcb")

        %% 5. IDENTIFY ADJACENT LINKS TO EXTEND AND REPEAT

        while length(NodeRoute)<maxL
            LinkChoice2=[RemainingLink(:,RemainingLink(2,:)==NodeRoute(1)|RemainingLink(2,:)==NodeRoute(end)),RemainingLink(:,RemainingLink(3,:)==NodeRoute(1)|RemainingLink(3,:)==NodeRoute(end))]; % create next round candidates
            LinkChoice22=LinkChoice2;
            nCandLink=size(LinkChoice2,2);
            for i=1:nCandLink % exclude nodes already on this route
                if sum(ismember(EdgeInfo(2:3,LinkChoice2(1,nCandLink-i+1))',NodeRoute))==2
                    LinkChoice2(:,nCandLink-i+1)=[]; % inversely indexed to avoid error
                end
            end
            nCandLink=size(LinkChoice2,2);
            % if all nodes are covered, randomly pick one route to extend
            % among adjacent nodes
 
            if nCandLink==0 % all links are already used: randomly choose one
                LinkChoice2=LinkChoice22; % create next round candidates
                nCandLink=size(LinkChoice2,2);
                LinkChoice2=LinkChoice2(:,randi(nCandLink));
                nCandLink=1;
            end
            
            ODChoice=cell(1,nCandLink);    % [total OD covered]
%             ODChoiceInd=zeros(nOD,nCandLink); % indicate ODs that covered by choices
            ODChoiceIndUncorr=zeros(nUncorrFlow,nCandLink);
            ODChoiceIndCorr=zeros(nCorrFlow,nCandLink);
            for i=1:nCandLink
%                 ODChoiceInd(:,i)=ODSystemNetInd;
                ODChoiceIndUncorr(:,i)=ODSystemNetIndUncorr;    % load indicators of ODs that covered by choices
                ODChoiceIndCorr(:,i)=ODSystemNetIndCorr;
            end
            Mu=zeros(nCandLink,1);      % prepare mean flow based on truth
            Mu0=zeros(nCandLink,1);     % prepare mean flow based on prior
            Sigma=zeros(nCandLink,1);	% prepare std.dev of flow based on truth
            Sigma0=zeros(nCandLink,1);	% prepare std.dev of flow based on prior

            for i=1:nCandLink
                ODTemp=[]; ODTemp2=[]; ODTemp3=[];
%                 RTStartA=NodeRouteList{LinkChoice2(2,i),2};
                RTStartA=RTGroups{RT,2};
                nRT_A=length(RTStartA);
                t=setdiff(LinkChoice2(2:3,i)',[NodeRoute(1),NodeRoute(end)]);
                s=setdiff(LinkChoice2(2:3,i),t);
                RTStartB=NodeRouteList{t,2}; % routes covering opposite end of link
                nRT_B=length(RTStartB); % # of routes covering opposite end of link
                % CLASSIFICATION OF LINK CASE
                for j=1:nRT_A
                    ODTemp2=Result(nSim+1).Route(RTStartA(j)).NodeRoute'; % nodes included in j-th route
%                     snode=setdiff(LinkChoice2(2:3,i)',ODTemp2);
%                     if snode>0
                        ODTemp2(:,2)=t;
    %                 ODTemp2=[ODTemp2;ODTemp2(:,2:-1:1)];
                        ODTemp=[ODTemp;ODTemp2];
%                     end
%                     ODTemp2(:,2)= LinkChoice2(3,i);
%                     ODTemp2=[ODTemp2;ODTemp2(:,2:-1:1)];
%                     ODTemp=[ODTemp;ODTemp2];
                end


                if nRT_B>0 % some routes covering opposite end
                    % Case III: new OD pairs are generated between
                    % 1) A and route covering B and not accessible from A
                    % 2) B and route covering A and not accessible from B
                    for j=1:nRT_B
                        % NEW OD PAIRS
                        % : BETWEEN A AND RTStartB
                        % : BETWEEN B AND RTStartA
                        ODTemp3=Result(nSim+1).Route(RTStartB(j)).NodeRoute'; % nodes included in j-th route
%                         ODTemp3(:,2)= LinkChoice2(2,i);
%                         ODTemp3=[ODTemp3;ODTemp3(:,2:-1:1)];
%                         ODTemp=[ODTemp;ODTemp3];
%                         snode=setdiff(LinkChoice2(2:3,i)',ODTemp3);
%                         if snode>0
                            ODTemp3(:,2)=s;
    %                     ODTemp3=[ODTemp3;ODTemp3(:,2:-1:1)];
                            ODTemp=[ODTemp;ODTemp3];
%                         end
                    end
                end
                
                ODTemp=unique(ODTemp,'rows');           % All unique OD pairs (i,j) of choice
                ODTemp=sort(ODTemp,2);
                ODFLOWIDTemp=zeros(size(ODTemp,1),1);   % Convert (i,j) to ODflowID
                for j=1:size(ODTemp,1)
                    [~,ODFLOWIDTemp(j,1)]=ismember(ODTemp(j,:),PUMAinfo(:,2:3),'rows');
                end
 
                ODFLOWIDTemp(ODFLOWIDTemp(:,1)==0,:)=[];
                ODChoice{1,i}=ODFLOWIDTemp';   % ODs covered by choice
                ODChoice{1,i}=setdiff(ODChoice{1,i},ODSystemNet);
                
                for j=1:size(ODChoice{1,i},2)
%                     ODChoiceInd(ODChoice{1,i}(j),i)=1;   % Add newly covered ODs
                    if ismember(ODChoice{1,i}(j),PrCorrMean(:,1)) % correlated
                        ODChoiceIndCorr(PrCorrMean(:,1)==ODChoice{1,i}(j),i)=1;
                    else
                        ODChoiceIndUncorr(PrUncorr(:,1)==ODChoice{1,i}(j),i)=1;
                    end
                end
                % PREPARE FUNCTION INPUTS
%                 Mu(i,1)=TrueODMean'*ODChoiceInd(:,i); % true mean flow by choosing a link
                Mu(i,1)=TrUncorr(:,2)'*ODChoiceIndUncorr(:,i)+TrCorrMean(:,2)'*ODChoiceIndCorr(:,i);
%                 Mu0(i,1)=PriorODMean(:,1)'*ODChoiceInd(:,i); % mean flow based on prior
                % #3 Mean of all observed OD flows
%                 Pom=PriorODMean(:,1);
%                 meanAll=mean(Pom(Pom>0));
%                 for j=1:nOD
%                     if ODChoiceInd(j,i)>0
%                         if PriorODMean(j,1)==0
%                             Mu0(i,1)=Mu0(i,1)+meanAll; % #3 mean of all observed values
%                         else 
%                             Mu0(i,1)=Mu0(i,1)+PriorODMean(j,1);
%                         end
%                     end
%                 end
                AllMeans=[PrCorrMean(:,2);PrUncorr(:,2)];
                meanAll=mean(AllMeans(AllMeans>0));
                for j=1:nUncorrFlow
                    if ODChoiceIndUncorr(j,i)>0 % j-th flow is covered by i-th choice
                        if PrUncorr(j,2)==0 % if not observed
                            Mu0(i,1)=Mu0(i,1)+meanAll; % add mean value of the observed instead of zero
                        else % if observed
                            Mu0(i,1)=Mu0(i,1)+PrUncorr(j,2); % add obseved mean flow
                        end
                    end
                end
                for j=1:nCorrFlow
                    if ODChoiceIndCorr(j,i)>0 % j-th flow is covered by i-th choice
                        if PrCorrMean(j,2)==0 % if not observed
                            Mu0(i,1)=Mu0(i,1)+meanAll; % add mean value of the observed instead of zero
                        else % if observed
                            Mu0(i,1)=Mu0(i,1)+PrCorrMean(j,2); % add obseved mean flow
                        end
                    end
                end
%                 Sigma(i,1)=(TrueODStdev').^2*ODChoiceInd(:,i);    % true variance by choosing a link
%                 Sigma0(i,1)=(PriorODStdev').^2*ODChoiceInd(:,i);  % variance by based on prior
                Sigma(i,1)=(TrUncorr(:,3)').^2*ODChoiceIndUncorr(:,i)+diag(TrCorrCov)'*ODChoiceIndCorr(:,i);
                Sigma0(i,1)=(PrUncorr(:,3)').^2*ODChoiceIndUncorr(:,i)+diag(PrCorrCov)'*ODChoiceIndCorr(:,i);
            end
            
%             TempAdjNode1=setdiff(ReachableNodes{NodeRoute(1),2},NodeRoute);
%             TempAdjNode1(2,:)=1;
%             TempAdjNode2=setdiff(ReachableNodes{NodeRoute(end),2},NodeRoute);
%             TempAdjNode2(2,:)=2;
%             TempAdjNode=[TempAdjNode1,TempAdjNode2];
%             tan=size(TempAdjNode,2);
%             tan2=randi(tan);
%             if TempAdjNode(2,tan2)==1
%                 LinkChoice2=LinkInfo(:,LinkInfo(2,:)==NodeRoute(1)&LinkInfo(3,:)==TempAdjNode(1,tan2));
%             else
%                 LinkChoice2=LinkInfo(:,LinkInfo(2,:)==NodeRoute(end)&LinkInfo(3,:)==TempAdjNode(1,tan2));
%             end
%             II=1;
%             II2=0;
            if sum(Mu)>0
                for i=1:nCandLink
                    if Mu(nCandLink-i+1,1)==0
                        LinkChoice2(:,nCandLink-i+1)=[];
                        Mu(nCandLink-i+1,:)=[];
                        Mu0(nCandLink-i+1,:)=[];
                        ODChoice(:,nCandLink-i+1)=[];
                    end
                end
                if mabsetting==1 % Multi-armed bandit
%                     [Mu_est, OC2, Choices, ObsOD, PriorODMean, PriorODStdev]=Example_mab_transfer_20220620(Mu,Mu0,M,ObsOD,PriorODMean,PriorODStdev,ODChoice,ODSystemNet,TrueODMean,TrueODStdev,TrueCov,CorFlow2);
                    [Mu_est, OC2, Choices, ObsOD, PrUncorr, PrCorrMean,PrecisU,PrecisC]=Example_mab_transfer_20220801(Mu,Mu0,M,ObsOD,ODChoice,ODSystemNet,PrUncorr,TrUncorr,PrCorrMean,TrCorrMean,TrCorrCov,PrecisU,PrecisC);
                elseif kggeneral==1 % Knowledge gradient
%                     [Mu_est, OC2, Choices, ObsOD, PriorODMean, PriorODStdev]=Example_kg_transfer_20220620(Mu,Mu0,Sigma,Sigma0,M,ObsOD,PriorODMean,PriorODStdev,ODChoice,ODSystemNet,TrueODMean,TrueODStdev,TrueCov,CorFlow2);
                    [Mu_est, OC2, Choices, ObsOD, PrUncorr, PrCorrMean,PrecisU,PrecisC]=Example_kg_transfer_20220801(Mu,Mu0,Sigma,Sigma0,M,ObsOD,ODChoice,ODSystemNet,PrUncorr,TrUncorr,PrCorrMean,TrCorrMean,TrCorrCov,PrecisU,PrecisC);
                else % Knowledge gradient with correlated belief
%                     [Mu_est, OC2, Choices, Mu_estALL, ObsOD, CovOD, PriorODMean]=Example_kgcb_PUMA_transfer_20220620(Mu,Mu0,M,ObsOD,CovOD,PriorODMean,ODChoice,ODSystemNet,TrueODMean,TrueODStdev,PUMAODinfo2,TrueCov,CorFlow2);
                    [Mu_est, OC2, Choices, Mu_estALL, ObsOD, PrUncorr, PrCorrMean, PrCorrCov,PrecisU,PrecisC]=Example_kgcb_PUMA_transfer_20220801(Mu,Mu0,M,ObsOD,ODChoice,ODSystemNet,PrUncorr,TrUncorr,PrCorrMean,PrCorrCov,TrCorrMean,TrCorrCov,FlowCluster,ODChoiceIndCorr,PrecisU,PrecisC);
                end
                [~,II]=max(Mu_est);
                [~,II2]=max(Mu);
            else
                II=randi(nCandLink);l
                II2=0;
            end
            
            nextLink=LinkChoice2(1,II);
            nextNode=setdiff(EdgeInfo(2:3,nextLink),NodeRoute);   % chosen node
            NodeSystemNet=unique([NodeSystemNet,nextNode]);            
            
            ATT=EdgeInfo(2:3,nextLink)==NodeRoute(end);
            if sum(ATT)==1
                NodeRoute=[NodeRoute,nextNode];   % in a sequence of connection
%                 [EdgeInfo(2:3,nextLink)';NodeRoute(end-1:end)]
            else
                NodeRoute=[nextNode,NodeRoute];  % extend in the opposite direction
%                 [EdgeInfo(2:3,nextLink)';NodeRoute(1:2)]
            end
%             if NodeRoute(end)==LinkChoice2(2,II)
%                 NodeRoute=[NodeRoute,nextNode];   % in a sequence of connection
%             else
%                 NodeRoute=[nextNode,NodeRoute];  % extend in the opposite direction
%             end
            NodeRouteList{nextNode,2}=[NodeRouteList{nextNode,2},RT];
            
            OppCost{length(NodeRoute),1}=RT;
            OppCost{length(NodeRoute),2}=nextNode;
            OppCost{length(NodeRoute),3}=II;
            OppCost{length(NodeRoute),4}=II2;
            OppCost{length(NodeRoute),5}=OC2;
            
            RTStartB=NodeRouteList{nextNode,2}; % routes covering opposite end of link
            nRT_B=length(RTStartB);
            for i=1:nRT_B
                RTintsct(RTStartB(i),RT)=1;
            end
            
            IncludedLink=[IncludedLink,RemainingLink(:,RemainingLink(1,:)==nextLink)];	% add chosen link pair
            RemainingLink(:,RemainingLink(1,:)==nextLink)=[]; % delete chosen link pair
            IncludedLink=sortrows(IncludedLink')';  % sort included links
            
            ODSystemNet=unique([ODChoice{1,II},ODSystemNet]);
%             ODSystemNetInd=ODChoiceInd(:,II);
            ODSystemNetIndUncorr=ODChoiceIndUncorr(:,II);    % total covered OD (indexed)
            ODSystemNetIndCorr=ODChoiceIndCorr(:,II);
            Result(nSim+1).Route(RT).NodeRoute=NodeRoute;
            for i=1:RT
                K=[];
                for j=1:length(Result(nSim+1).Route(i).NodeRoute)
                    K=[K,NodeRouteList{Result(nSim+1).Route(i).NodeRoute(j),2}];
                end
                RTGroups{i,2}=unique(K);            
            end
            
            for i=1:RT
                ODTemp=[];
                if RTintsct(i,RT)==1
                    ODTemp=Result(nSim+1).Route(i).NodeRoute';
                    ODTemp(:,2)=nextNode;
                 end
                ODTemp=unique(ODTemp,'rows');           % All unique OD pairs (i,j) of choice
                ODFLOWIDTemp=zeros(size(ODTemp,1),1);   % Convert (i,j) to ODflowID
                for j=1:size(ODTemp,1)
                    [~,ODFLOWIDTemp(j,1)]=ismember(ODTemp(j,:),PUMAinfo(:,2:3),'rows');
                end

                ODFLOWIDTemp(ODFLOWIDTemp(:,1)==0,:)=[];
                ODwithRTpair{i,RT}=[ODwithRTpair{i,RT},ODFLOWIDTemp'];
            end 
%             NodeRoute
        end

        EstMeanODFlow=[EstMeanODFlow,[PrUncorr(:,1:2);PrCorrMean(:,1:2)]];
        Result(nSim+1).ServingOD{RT,1}=ODSystemNet;
        OPPCOST=[OPPCOST;OppCost];
%         RT        
        Result(nSim+1).Route(RT).NodeRoute=NodeRoute;
    
    end
    TrODMean=[TrUncorr(:,1:2);TrCorrMean(:,1:2)];
    nSim=nSim+1
    Result(nSim).EstMeanODFlow=EstMeanODFlow;
    Result(nSim).OPPCOST=OPPCOST;
    Result(nSim).Err(1,:)=Result(nSim).Err(1,:)+1;
    T(nSim,1)=toc;
    catch
        Result(nSim+1).Err(1,2)=Result(nSim+1).Err(1,2)+1;
%         skip
    end
end

%% 6. YIELD RESULTS
% COVERED TRUE DEMAND
TotFlow=zeros(Run,2*RT);   % column1: est, column2: true
for i=1:Run
    for j=1:RT
        for k=1:size(Result(i).ServingOD{j,1},2)
            TotFlow(i,j)=TotFlow(i,j)+Result(i).EstMeanODFlow(Result(i).EstMeanODFlow(:,1)==Result(i).ServingOD{j,1}(k),end);
            TotFlow(i,j+RT)=TotFlow(i,j+RT)+TrODMean(Result(i).EstMeanODFlow(:,1)==Result(i).ServingOD{j,1}(k),2);
        end
    end
end

% OPTIMAL CHOICE RATE
OptChc=zeros(Run,1);
for j=1:Run
    Chc=zeros(1,6); %[Total iteration, # of optimal choice, # of optimal+random choice]
    for k=1:nReqRoute*maxL
        if Result(j).OPPCOST{k,3}>0
            Chc(1,1)=Chc(1,1)+1;
            if Result(j).OPPCOST{k,3}==Result(j).OPPCOST{k,4}
                Chc(1,2:3)=Chc(1,2:3)+1;
            elseif Result(j).OPPCOST{k,4}==0
                Chc(1,3)=Chc(1,3)+1;
            end
        end
    end
    OptChc(j,1)=Chc(1,2)/Chc(1,1);
    OptChc(j,2)=Chc(1,3)/Chc(1,1);
end

% ERROR RATE
ErrRate=zeros(1,2);
for j=1:Run
    ErrRate=ErrRate+Result(j).Err;
end
Result = rmfield(Result,'Err');

% AGGREGATED OPPORTUNITY COST
% SumOc=zeros(Run,1);
% for j=1:Run
%     Oc=zeros(nReqRoute*(maxL-1),M);
%     k=1;
%     for i=1:nReqRoute*(maxL)
%         if size(Result(j).OPPCOST{i,5},2)>0
%             Oc(k,:)=Result(j).OPPCOST{i,5};
%             k=k+1;
%         end
%     end
%     SumOc(j,1)=sum(Oc(:,10));
% end
end